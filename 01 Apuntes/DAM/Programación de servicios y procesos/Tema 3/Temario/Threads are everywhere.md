---
dg-publish: true
---

# Los Hilos están en todas partes 

Incluso si tu programa nunca crea explícitamente un hilo, los frameworks pueden crear hilos en su nombre, y el código llamado desde estos hilos debe ser thread safe. Esto puede suponer una carga significativa durante el diseño y implementación para los desarrolladores, ya que el desarrollo de clases seguras para hilos requiere más cuidado y análisis que el desarrollo de clases no thread safe.

Todas las aplicaciones de Java utilizan hilos. Cuando se inicia la JVM, crea hilos para las tareas de limpieza de la JVM (garbage collection, finalización) y un hilo principal para ejecutar el método principal. Los frameworks de la interfaz de usuario de AWT (Abstract Window Toolkit) y Swing crean hilos para administrar los eventos de la interfaz de usuario. El temporizador crea hilos para ejecutar tareas diferidas. Los frameworks de componentes, como los Servlets y RMI, crean grupos de hilos e invocan métodos de componentes en estos hilos.

Si utilizas estas funciones como muchos desarrolladores, debes estar familiarizado con la concurrencia y thread safe, porque estos frameworks crean hilos y llaman a sus componentes desde ellos. Sería bueno creer que la concurrencia es una característica del lenguaje "opcional" o "avanzada", pero la realidad es que casi todas las aplicaciones Java son multihilo y estos frameworks no te aíslan de la necesidad de coordinar correctamente el acceso al estado de la aplicación. 

Cuando un framework introduce concurrencia en una aplicación, generalmente es imposible restringir el conocimiento de la simultaneidad al código del framework, porque los frameworks, por su naturaleza, hacen devoluciones de llamada a los componentes de la aplicación que, a su vez, acceden al estado de la aplicación. De manera similar, la necesidad de thread safety no termina con los componentes llamados por el framework, se extiende a todas las rutas de código que acceden al estado del programa al que acceden esos componentes. Por lo tanto, la necesidad de seguridad en los hilos es contagiosa. 

Todas las funciones que se describen a continuación hacen que se llame al código de la aplicación desde hilos no administrados por la aplicación. Si bien la necesidad de thread safety puede comenzar con estas instancias, rara vez termina allí; en cambio, se propaga por la aplicación. 

**Temporizador**. El temporizador es un mecanismo conveniente para programar tareas para que se ejecuten en un momento futuro, ya sea una vez o periódicamente. La introducción de un temporizador puede complicar un programa que de otro modo sería secuencial, porque las TimerTasks se ejecutan en un hilo administrado por el temporizador, no por la aplicación. Si un TimerTask accede a datos a los que también acceden otros hilos de la aplicación, entonces no solo el TimerTask debe hacerlo en modo ThreadSafe, sino también cualquier otra clase que acceda a esos datos. A menudo, la forma más fácil de lograr esto es asegurarse de que los objetos a los que accede TimerTask sean ThreadSafe, encapsulando así la seguridad para hilos dentro de los objetos compartidos. 

**Servlets y JavaServer Pages (JSPs)**. El framework de servlets está diseñado para manejar toda la infraestructura de implementación de una aplicación web y proceso de solicitudes de clientes HTTP remotos. Una solicitud que llega al servidor se envía, quizás mediante una cadena de filtros, al servlet o a la página JSP correspondiente. Cada servlet representa un componente de la lógica de la aplicación y, en sitios web de gran volumen, varios clientes pueden requerir los servicios del mismo servlet a la vez. La especificación de servlets requiere que un servlet esté preparado para ser llamado simultáneamente desde múltiples subprocesos. En otras palabras, los servlets deben ser ThreadSafe. Incluso si pudiera garantizar que un servlet solo se llama desde un hilo a la vez, aún tendría que se ThreadSafe al crear una aplicación web. Los servlets a menudo acceden a la información de estado compartida con otros servlets, como los objetos de ámbito de aplicación (los almacenados en ServletContext) o los objetos de ámbito de sesión (los almacenados en la HttpSession por cliente). Cuando un servlet accede a objetos compartidos a través de servlets o solicitudes, debe coordinar el acceso a estos objetos correctamente, ya que varias solicitudes podrían acceder a ellos simultáneamente desde hilos separados. Los servlets y JSP, así como los filtros de servlets y los objetos almacenados en contenedores de ámbito como ServletContext y HttpSession, simplemente tienen que ser ThreadSafe.

Invocación de método remoto. RMI (Remote Method Invocation) permite invocar métodos en objetos que se ejecutan en otra JVM. Cuando se llama a un método remoto con RMI, los argumentos del método se empaquetan (marshalled) en un flujo de bytes y se envían a través de la red a la JVM remota, donde se desempaquetan (unmarshalled) y se pasan al método remoto.

Cuando el código RMI llama a su objeto remoto, ¿en qué hilo ocurre esa llamada? No se sabe, pero definitivamente no está en un hilo que se creó, el objeto se llama en un hilo administrado por RMI. ¿Cuántos hilos crea RMI? ¿Se podría llamar al mismo método remoto en el mismo objeto remoto simultáneamente en varios hilos RMI? Respuesta: sí, pero no está del todo claro desde el JavaDoc (leer la especificación del RMI).

Un objeto remoto debe protegerse contra dos peligros de seguridad del hilo: coordinar adecuadamente el acceso al estado que puede ser compartido con otros objetos y coordinar adecuadamente el acceso al estado del propio objeto remoto (ya que el mismo objeto puede ser llamado en múltiples hilos simultáneamente). Al igual que los servlets, los objetos RMI deben estar preparados para múltiples llamadas simultáneas y deben proporcionar sus propios mecanismos para hacerlos ThreadSafe.

**Swing y AWT**: Las aplicaciones de GUI son intrínsecamente asincrónicas. Los usuarios pueden seleccionar un elemento del menú o presionar un botón en cualquier momento, y esperan que la aplicación responda rápidamente incluso si está en medio de hacer otra cosa. Swing y AWT abordan este problema creando un hilo separado para manejar eventos iniciados por el usuario y actualizar la vista gráfica presentada al usuario. Los componentes de swing, como JTable, no son ThreadSafe. En cambio, los programas Swing logran su seguridad de hilos al limitar todo el acceso a los componentes de la GUI al subproceso de eventos. Si una aplicación desea manipular la GUI desde fuera del hilo del evento, debe hacer que el código que manipulará la GUI se ejecute en el hilo del evento de actualización del a GUI. Cuando el usuario realiza una acción de UI, se llama a un controlador de eventos en el hilo de eventos para realizar cualquier operación que solicite el usuario. Si el controlador necesita acceder al estado de la aplicación al que también se accede desde otros hilos (como un documento que se está editando), entonces el controlador de eventos, junto con cualquier otro código que acceda a ese estado, debe hacerlo mediante mecanismos de ThreadSafe